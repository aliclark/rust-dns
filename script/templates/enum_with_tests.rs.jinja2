
#[repr({{rep}})]
#[deriving(PartialEq,Show)]
pub enum {{ename}} {
    {% for variant in variants %}{{variant.name_justified}} = {{variant.value}},
    {% endfor %}
}

impl {{ename}} {
    /// Convert a `{{rep}}` integer to a `{{ename}}` variant. Undefined values are
    /// mapped to `{{ename}}::{{default}}`.
    pub fn from_{{rep}}(val: {{rep}}) -> {{ename}} {
        match val {
            {% for variant in variants %}{{variant.value_justified}} => {{ename}}::{{variant.name}},
            {% endfor %}
            _ => {{ename}}::{{default}},
        }
    }
    pub fn to_{{rep}}({{ename|lower}}: {{ename}}) -> {{rep}} {
        {{ename|lower}} as {{rep}}
    }
    pub fn from_str(val: &str) -> {{ename}} {
        match val {
            {% for variant in variants %}{{variant.name_str_justified}} => {{ename}}::{{variant.name}},
            {% endfor %}
            _ => {{ename}}::{{default}},
        }
    }
    {% if with_desc %}
    pub fn get_description(variant: {{ename}}) -> &'static str {
        match variant {
            {% for variant in variants %}{{variant.qname_justified}} => "{{variant.desc}}",
            {% endfor %}
        }
    }{% endif %}
}

#[cfg(test)]
mod test_{{ename|lower}} {
    use super::{{ename}};
    
    /// Quick and dirty {{rep}} match checking.
    #[test]
    fn test_{{ename|lower}}_value() {
        {% set variant = variants[0] %}
        let qt = {{ename}}::{{variant.name}};
        match qt as {{rep}} {
            {{variant.value}} =>    assert!(true),
            _ =>    assert!(false),
        };
    }

    /// Test that defined `QTYPE`s have corresponding variants, and check
    /// that defined `QTYPE` variants translate to/from their {{rep}} values.
    /// Also checks that undefined `QTYPE`s are mapped to `{{default}}`.
    #[test]
    fn test_{{ename|lower}}_identity() {
        let defined_{{ename|lower}}s = [
                                {% for variant in variants %}{{variant.value}}{{rep}},
                                {%endfor%}
                            ];
        let skip = {{ename}}::{{default}} as {{rep}};
        // Fuzz all 65536 values possible for QTYPE
        'rng: for val_u in range(0, {{rep_ceiling}}) {
            if (val_u as {{rep}}) == skip {
                continue 'rng;
            }
            let val: {{rep}} = val_u as {{rep}};
            'defs: for &defval in defined_{{ename|lower}}s.iter() {
                // Do some checks on defined QTYPEs
                if defval == val {
                    // Make sure it doesn't translate to reserved
                    assert!({{ename}}::{{default}} != {{ename}}::from_{{rep}}(val));

                    // Make sure converstion from-to-from {{rep}}
                    // has the same result.
                    let from_{{rep}} = {{ename}}::from_{{rep}}(val);
                    let to_{{rep}} = from_{{rep}} as {{rep}};
                    assert!(from_{{rep}} == {{ename}}::from_{{rep}}(to_{{rep}}));
                    assert!(to_{{rep}} == {{ename}}::to_{{rep}}(from_{{rep}}));

                    // If we're good, we can stop checking
                    // the defined QTYPEs list and go to the
                    // next value.
                    continue 'rng;
                }
            }
            // Check everything else is reserved
            assert!({{ename}}::{{default}} == {{ename}}::from_{{rep}}(val));
        }
    }
}